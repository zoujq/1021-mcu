C51 COMPILER V9.56.0.0   MAIN                                                              10/18/2020 09:54:06 PAGE 1   


C51 COMPILER V9.56.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Output\Main.obj
COMPILER INVOKED BY: F:\Keil\C51\BIN\C51.EXE ..\..\User\Main.c OMF2 OPTIMIZE(8,SPEED) BROWSE INCDIR(..\..\Application;..
                    -\..\User\INC;..\..\Libraries;..\..\User\pt_os) DEBUG PRINT(.\List\Main.lst) TABS(2) OBJECT(.\Output\Main.obj)

line level    source

   1          //================================================================================
   2          #define  ALLOCATE_EXTERN
   3          #include "YX23F01CB.h"
   4          #include "YX23F01CB_SYS.h"
   5          #include "YX23F01CB_IO_INIT.h"
   6          #include "YX23F01CB_GeneralKey_Touch_Lib_V1.04\YX23F01CB_GeneralKey_Touch_Lib.h"
   7          #include "YX23F01CB_GeneralKey_Touch_Lib_V1.04\YX23F01CB_GeneralKey_Touch_Filter.h"
   8          #include "YX23F01CB_GeneralKey_Touch_Lib_V1.04\YX23F01CB_GeneralKey_Touch_Multibutton.h"
   9          #include "YX23F01CB_TouchUartDebug_Lib_V1.00\YX23F01CB_TouchUartDebug_Lib_CFG.h"
  10          #include "YX23F01CB_TouchUartDebug_Lib_V1.00\YX23F01CB_TouchUartDebug_Lib.h"
  11          #include "delay.h"
  12          #include <stdio.h>
  13          #include "pt.h"
  14          
  15          #define TK1 1<<15
  16          #define TK2 1<<14
  17          #define TK3 1<<13
  18          #define TK4 1<<12
  19          #define TK5 1<<11
  20          
  21          
  22          extern void init_printf();
  23          void init_ntc_adc();
  24          void init_display();
  25          void display_temp(unsigned char temp);
  26          unsigned int get_ntc_adc();
  27          void  buzzer();
  28          u16 get_temp();
  29          void init_TIMER0();
  30          static int dislay(struct pt *pt);
  31          //================================================================================
  32          
  33          char display_buff[4]={0,0,0,0};
  34          char display_point=0;
  35          u32 yuyue_counter=0;
  36          u32 dingshi_counter=0;
  37          u32 yanshi_counter=0;
  38          char work_mode=0;
  39          int set_temp=0;
  40          char display_mode=0;
  41          
  42          static struct pt pt1, pt2;
  43          //================================================================================
  44          void main()
  45          {
  46   1        u16 last_TK=0;
  47   1        u16 temp=0;
  48   1        SystemInit();           //Ê±ÖÓ³õÊ¼»¯º¯Êý(Ä¬ÈÏFosc=Fcpu=16M)
  49   1      //  IO_Init();
  50   1        init_printf();
  51   1      //  init_ntc_adc();
  52   1        init_display();
  53   1          init_TIMER0();
  54   1        EA = 1;
C51 COMPILER V9.56.0.0   MAIN                                                              10/18/2020 09:54:06 PAGE 2   

  55   1        CTK_Init(); 
  56   1                    
  57   1      
  58   1        //printf("start\n\r");
  59   1      
  60   1        P0M3=GPIO_Out_PP;//buzzer
  61   1      
  62   1      //  temp=get_temp();
  63   1      
  64   1        PT_INIT(&pt1);
  65   1          PT_INIT(&pt2);
  66   1        while(1)
  67   1        {
  68   2      //    display_temp(temp);
  69   2          if(OneCycleScanDone)
  70   2          {
  71   3            TouchRawDataFilter();   //RawDataÂË²¨º¯Êý£¬ÈçÐèÊ¹ÄÜÊý¾ÝÂË²¨£¬ÐèÔÚYX23F01CB_GeneralKey_Touch_Filter.hÖÐÉè
             -ÖÃÂË²¨Éî¶È£¬´Ëº¯Êý²»¿ÉÉ¾³ý
  72   3            Touch_Signal_Handle();
  73   3            TouchMultibuttonHandle(); //×îÇ¿°´¼ü´¦Àíº¯Êý£¬Èç¹û´óÓÚµÈÓÚÁ½¸ö°´¼üÍ¬Ê±ÓÐÐ§£¬ÄÇÃ´´¥ÃþÐÅºÅ×îÇ¿µÄ°´¼üÅÐ¶ÏÎ
             -ªÓÐÐ§£¬ÆäËû°´¼üÎÞÐ§
  74   3            OneCycleScanDone = 0;
  75   3      
  76   3          }
  77   2          
  78   2          if(TouchKeyFlag )
  79   2          {
  80   3            extern ux16 XDATA_RawDataBuf[];     
  81   3            
  82   3            if(last_TK!=TouchKeyFlag)
  83   3            {
  84   4              last_TK=TouchKeyFlag;
  85   4              buzzer();
  86   4            }
  87   3      //      printf("TouchKeyFlag=0x%X,XDATA_RawDataBuf[0]=%d\n\r",TouchKeyFlag,XDATA_RawDataBuf[0]);
  88   3            
  89   3      //      if(TouchKeyFlag == TK1)
  90   3      //      {
  91   3      //         printf("TK1\n\r");
  92   3      //      }
  93   3      //      else if(TouchKeyFlag == TK2)
  94   3      //      {
  95   3      //         printf("TK2\n\r");
  96   3      //      }
  97   3      //      else if(TouchKeyFlag == TK3)
  98   3      //      {
  99   3      //         printf("TK3\n\r");
 100   3      //      }
 101   3      //      else if(TouchKeyFlag == TK4)
 102   3      //      {
 103   3      //         printf("TK4\n\r");
 104   3      //      }
 105   3      //      else if(TouchKeyFlag == TK5)
 106   3      //      {
 107   3      //         printf("TK5\n\r");
 108   3      //      }
 109   3          }
 110   2          else{
 111   3            last_TK=0;
 112   3          }
 113   2          dislay(&pt1);
 114   2          
C51 COMPILER V9.56.0.0   MAIN                                                              10/18/2020 09:54:06 PAGE 3   

 115   2            // printf("start%d\n\r",sizeof(long));
 116   2          
 117   2      //    printf("%d,temp=%d\n\r",get_ntc_adc(),get_temp());
 118   2          // Delay_ms(3000);
 119   2        }
 120   1      }
 121          
 122          /*************************************ADC************************************************/
 123          u16 code Temp_Table[100]={
 124          3815,3788,3761,3734,3707,3680,3653,3626,3599,3572,3545,3518,3491,3464,3437,3410,3383,3356,
 125            3329,3302,3275,3248,3221,3194,3167,3140,3113,3086,3059,3032,3005,2978,2951,2924,2897,2870,
 126            2843,2816,2789,2762,2735,2708,2681,2654,2627,2600,2573,2546,2519,2492,2465,2438,2411,2384,
 127            2357,2330,2303,2276,2249,2222,2195,2168,2141,2114,2087,2060,2033,2006,1979,1952,1925,1898,
 128            1871,1844,1817,1790,1763,1736,1709,1682,1655,1628,1601,1574,1547,1520,1493,1466,1439,1412,
 129            1385,1358,1331,1304,1277,1250,1223,1196,1169,1142
 130          };
 131          
 132          void init_ntc_adc()
 133          {
 134   1        
 135   1        P0M2 = 0x01;                //P02ÉèÖÃÎªÄ£ÄâÊäÈë
 136   1        ADCC0 = 0x80;           //´ò¿ªADC×ª»»µçÔ´
 137   1        Delay_50us(1);            //ÑÓÊ±50us£¬È·±£ADCÏµÍ³ÎÈ¶¨
 138   1        ADCC1 = 2;            //Ñ¡ÔñÍâ²¿Í¨µÀ2
 139   1        ADCC2 = 0x4B;           //×ª»»½á¹û12Î»Êý¾Ý£¬Êý¾ÝÓÒ¶ÔÆë£¬ADCÊ±ÖÓ16·ÖÆµ
 140   1      
 141   1        //NTC POWER
 142   1        P2M0=GPIO_Out_PP; 
 143   1        P2_0=1;
 144   1        
 145   1        
 146   1      }
 147          unsigned int get_ntc_adc()
 148          {
 149   1          ADCC0 |= 0x40;          //Æô¶¯ADC×ª»»
 150   1          while(!(ADCC0&0x20));     //µÈ´ýADC×ª»»½áÊø
 151   1          ADCC0 &=~ 0x20;         //Çå³ý±êÖ¾Î»
 152   1          return ADCR;
 153   1      }
 154          
 155          u16 get_temp()
 156          {
 157   1        u16 n=0;
 158   1        u16 ntc_adc=get_ntc_adc();
 159   1        
 160   1        for(n=0;n<100;n++)
 161   1        {
 162   2          if(Temp_Table[n]<ntc_adc)
 163   2          {
 164   3            break;
 165   3          }
 166   2        }
 167   1        return n;
 168   1      
 169   1      }
 170          
 171          
 172          /************************************ÊýÂë¹Ü***************************************/
 173          //Ñô¼«
 174          #define DISPLAY_A P2_6
 175          #define DISPLAY_B P2_4
 176          #define DISPLAY_C P3_4
C51 COMPILER V9.56.0.0   MAIN                                                              10/18/2020 09:54:06 PAGE 4   

 177          #define DISPLAY_D P2_2
 178          #define DISPLAY_E P2_1
 179          #define DISPLAY_F P2_5
 180          #define DISPLAY_G P3_5
 181          #define DISPLAY_H P2_3
 182          //Òõ¼«
 183          #define DISPLAY_COM1 P0_7
 184          #define DISPLAY_COM2 P0_1
 185          #define DISPLAY_COM3 P0_0
 186          #define DISPLAY_COM4 P2_7
 187          
 188          void init_display()
 189          {
 190   1        P2M6=GPIO_Out_PP;
 191   1        P2M4=GPIO_Out_PP;
 192   1        P3M4=GPIO_Out_PP;
 193   1        P2M2=GPIO_Out_PP;
 194   1        P2M1=GPIO_Out_PP;
 195   1        P2M5=GPIO_Out_PP;
 196   1        P3M5=GPIO_Out_PP;
 197   1        P2M3=GPIO_Out_PP;
 198   1        
 199   1        P0M7=GPIO_Out_PP;
 200   1        P0M1=GPIO_Out_PP;
 201   1        P0M0=GPIO_Out_PP;
 202   1        P2M7=GPIO_Out_PP;
 203   1        DISPLAY_COM1=1;
 204   1        DISPLAY_COM2=1;
 205   1        DISPLAY_COM3=1;
 206   1        DISPLAY_COM4=1;
 207   1      
 208   1      }
 209          static int dislay(struct pt *pt)
 210          {
 211   1        PT_BEGIN(pt);
 212   3        while(1)
 213   3        {
 214   4          switch(display_mode)
 215   4          {
 216   5            case 0:
 217   5              display_buff[0]=8;
 218   5              display_buff[1]=8;
 219   5              display_buff[2]=8;
 220   5              display_buff[3]=8;
 221   5              display_point=1;
 222   5              break;
 223   5            case 1:
 224   5              break;
 225   5            case 2:
 226   5              break;
 227   5            case 3:
 228   5              break;
 229   5            case 4:
 230   5              break;
 231   5            default:
 232   5      
 233   5              break;
 234   5          }
 235   4        }
 236   3        PT_END(pt);
 237   1      }
 238          void display_flash()
C51 COMPILER V9.56.0.0   MAIN                                                              10/18/2020 09:54:06 PAGE 5   

 239          {
 240   1        static char position=0;
 241   1        
 242   1        DISPLAY_COM1=1;
 243   1        DISPLAY_COM2=1;
 244   1        DISPLAY_COM3=1;
 245   1        DISPLAY_COM4=1;
 246   1        switch(display_buff[position])
 247   1        {
 248   2          case 0:   
 249   2            DISPLAY_A=1;DISPLAY_B=1;DISPLAY_C=1;DISPLAY_D=1;DISPLAY_E=1;DISPLAY_F=1;DISPLAY_G=0;    
 250   2        
 251   2            break;
 252   2          case 1:
 253   2            DISPLAY_A=0;DISPLAY_B=1;DISPLAY_C=1;DISPLAY_D=0;DISPLAY_E=0;DISPLAY_F=0;DISPLAY_G=0;
 254   2            break;
 255   2          case 2:
 256   2            DISPLAY_A=1;DISPLAY_B=1;DISPLAY_C=0;DISPLAY_D=1;DISPLAY_E=1;DISPLAY_F=0;DISPLAY_G=1;
 257   2            break;
 258   2          case 3:
 259   2            DISPLAY_A=1;DISPLAY_B=1;DISPLAY_C=1;DISPLAY_D=1;DISPLAY_E=0;DISPLAY_F=0;DISPLAY_G=1;
 260   2            break;
 261   2          case 4:
 262   2            DISPLAY_A=0;DISPLAY_B=1;DISPLAY_C=1;DISPLAY_D=0;DISPLAY_E=0;DISPLAY_F=1;DISPLAY_G=1;  
 263   2            break;
 264   2          case 5:
 265   2            DISPLAY_A=1;DISPLAY_B=0;DISPLAY_C=1;DISPLAY_D=1;DISPLAY_E=0;DISPLAY_F=1;DISPLAY_G=1;  
 266   2            break;
 267   2          case 6:
 268   2            DISPLAY_A=1;DISPLAY_B=0;DISPLAY_C=1;DISPLAY_D=1;DISPLAY_E=1;DISPLAY_F=1;DISPLAY_G=1;  
 269   2            break;
 270   2          case 7:
 271   2            DISPLAY_A=1;DISPLAY_B=1;DISPLAY_C=1;DISPLAY_D=0;DISPLAY_E=0;DISPLAY_F=0;DISPLAY_G=0;  
 272   2            break;
 273   2          case 8:
 274   2            DISPLAY_A=1;DISPLAY_B=1;DISPLAY_C=1;DISPLAY_D=1;DISPLAY_E=1;DISPLAY_F=1;DISPLAY_G=1;  
 275   2            break;
 276   2          case 9:
 277   2            DISPLAY_A=1;DISPLAY_B=1;DISPLAY_C=1;DISPLAY_D=1;DISPLAY_E=0;DISPLAY_F=1;DISPLAY_G=1;
 278   2            break;
 279   2          case 'E':
 280   2            DISPLAY_A=1;DISPLAY_B=0;DISPLAY_C=0;DISPLAY_D=1;DISPLAY_E=1;DISPLAY_F=1;DISPLAY_G=1;  
 281   2            break;    
 282   2          case '+':
 283   2            DISPLAY_A=0;DISPLAY_B=0;DISPLAY_C=0;DISPLAY_D=0;DISPLAY_E=0;DISPLAY_F=0;DISPLAY_G=0;  
 284   2            break;  
 285   2          default:
 286   2            
 287   2            break;
 288   2        
 289   2        }
 290   1        if(display_point)
 291   1        {
 292   2          DISPLAY_H=1;
 293   2        }
 294   1        if(position==0)
 295   1        {   
 296   2          DISPLAY_COM1=0;
 297   2          DISPLAY_COM2=1;
 298   2          DISPLAY_COM3=1;
 299   2          DISPLAY_COM4=1;
 300   2      
C51 COMPILER V9.56.0.0   MAIN                                                              10/18/2020 09:54:06 PAGE 6   

 301   2        }
 302   1        else if(position==1) 
 303   1        {
 304   2          DISPLAY_COM1=1;
 305   2          DISPLAY_COM2=0;
 306   2          DISPLAY_COM3=1;
 307   2          DISPLAY_COM4=1;
 308   2        }
 309   1        else if(position==2)
 310   1        {
 311   2          DISPLAY_COM1=1;
 312   2          DISPLAY_COM2=1;
 313   2          DISPLAY_COM3=0;
 314   2          DISPLAY_COM4=1;
 315   2        }
 316   1        else if(position==3)
 317   1        {
 318   2          DISPLAY_COM1=1;
 319   2          DISPLAY_COM2=1;
 320   2          DISPLAY_COM3=1;
 321   2          DISPLAY_COM4=0;
 322   2        }
 323   1        position++;
 324   1        if(position>3)
 325   1        {
 326   2          position=0;
 327   2        }
 328   1      }
 329          void display_temp(unsigned char temp)
 330          {
 331   1        char b_1=0;
 332   1        char b_2=0;
 333   1        char b_3=0;
 334   1        if(temp>120)
 335   1        {
 336   2          temp=120;
 337   2        }
 338   1        display_buff[0]=temp%10;
 339   1        display_buff[1]=(temp%100)/10;
 340   1        display_buff[2]=temp/100;
 341   1        display_buff[3]=0;
 342   1        display_point=1;
 343   1      
 344   1      }
 345          void  buzzer()
 346          {
 347   1        int i=0;
 348   1        
 349   1        for(i=0;i<500;i++){
 350   2          P0_3=1;
 351   2          Delay_50us(3);
 352   2          P0_3=0;
 353   2          Delay_50us(3);
 354   2        }
 355   1        
 356   1        
 357   1      }
 358          void init_TIMER0()
 359          {
 360   1        TCON1 = 0x00;           //Tx0¶¨Ê±Æ÷Ê±ÖÓÎªFosc/12
 361   1        TMOD = 0x00;            //16Î»ÖØ×°ÔØ¶¨Ê±Æ÷/¼ÆÊýÆ÷
 362   1      
C51 COMPILER V9.56.0.0   MAIN                                                              10/18/2020 09:54:06 PAGE 7   

 363   1        //Tim0¼ÆËãÊ±¼ä  = (65536 - 0xFACB) * (1 / (Fosc /Timer·ÖÆµÏµÊý))
 364   1        //        = 1333 / (16000000 / 12)
 365   1        //        = 1 ms
 366   1      
 367   1        //¶¨Ê±1ms
 368   1        //·´ÍÆ³õÖµ  = 65536 - ((1/1000) / (1/(Fosc / Timer·ÖÆµÏµÊý)))
 369   1        //        = 65536 - ((1/1000) / (1/(16000000 / 12)))
 370   1        //      = 65536 - 1333
 371   1        //      = 0xFACB
 372   1        
 373   1        TH0 = 0xFA;
 374   1        TL0 = 0xCB;             //T0¶¨Ê±Ê±¼ä1ms
 375   1        IE |= 0x02;             //´ò¿ªT0ÖÐ¶Ï
 376   1        TCON |= 0x10;           //Ê¹ÄÜT0
 377   1          
 378   1      }
 379          
 380          void TIMER0_Rpt(void) interrupt TIMER0_VECTOR
 381          {
 382   1        // P0_3 =~ P0_3;
 383   1        display_flash();            //P03·­×ª
 384   1        if(yuyue_counter>0)
 385   1        {
 386   2          yuyue_counter--;
 387   2          if(yuyue_counter==0)
 388   2          {
 389   3            work_mode=1;
 390   3          }
 391   2        }
 392   1        else if(dingshi_counter>0)
 393   1        {
 394   2          dingshi_counter--;
 395   2          if(dingshi_counter==0)
 396   2          {
 397   3            work_mode=0;
 398   3          }
 399   2        }
 400   1        
 401   1      }
 402          //void init
 403          /*********************************END OF FILE************************************/
 404          
 405          
 406          
 407          
 408          
 409          
 410          
 411          
 412          
 413          
 414          
 415          
 416          
 417          
 418          
 419          
 420          
 421          
 422          
 423          
 424          
C51 COMPILER V9.56.0.0   MAIN                                                              10/18/2020 09:54:06 PAGE 8   

 425          
 426          
 427          
 428          
 429          
 430          
 431          
 432          
 433          
 434          
 435          
 436          
 437          
 438          
 439          
 440          
 441          
 442          
 443          
 444          
 445          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    899    ----
   CONSTANT SIZE    =    200    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     26      10
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
